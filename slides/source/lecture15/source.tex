% (c) Nikita Lisitsa, lisyarus@gmail.com, 2021

\documentclass{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{adjustbox}

\usepackage{color}
\usepackage{soul}

\usepackage{hyperref}

\usepackage{amsmath}

\usepackage{tikz}
\usetikzlibrary{decorations}
\usetikzlibrary{decorations.pathreplacing}
\usepackage{xifthen}

\definecolor{red}{rgb}{1,0,0}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{blue}{rgb}{0,0,1}
\definecolor{magenta}{rgb}{0.75,0,0.75}

\makeatletter
\newcommand{\slideimage}[1]{
  \begin{figure}
    \begin{adjustbox}{width=\textwidth, totalheight=\textheight-2\baselineskip-2\baselineskip,keepaspectratio}
      \includegraphics{#1}
    \end{adjustbox}
  \end{figure}
}
\makeatother

\title{Компьютерная графика}
\subtitle{Лекция 15: оптимизация рендеринга, timer queries, frustum culling, occlusion culling, instancing}
\date{2021}

\setbeamertemplate{footline}[frame number]

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
\frametitle{Оптимизация \textendash{} это сложно}
На производительность (CPU) влияют:
\pause
\begin{itemize}
\item Общая загруженность системы
\pause
\item Количество и паттерн доступов к памяти (cache-friendliness)
\pause
\item Помещаются ли данные в кэш
\pause
\item Branch prediction
\pause
\item Как функции программы лежат в памяти (опять кэш)
\pause
\item Многое другое
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Оптимизация на GPU \textendash{} это очень сложно}
\begin{itemize}
\item Асинхронность
\pause
\item Параллельность
\pause
\item Много встроенных операций (fixed-function pipeline)
\pause
\item Сложные операции с памятью (доступ к текстуре: mipmaps + фильтрация)
\pause
\item Многое другое
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Измерение времени работы \textendash{} неправильный способ}
\begin{verbatim}
while (true) {
  auto frame_start = clock::now();

  // нарисовали сцену
  ...

  auto frame_end = clock::now();

  SwapBuffers();
}
\end{verbatim}
\pause
\begin{itemize}
\item \verb|frame_end - frame_start| \textendash{} сколько времени ушло на то, чтобы \textbf{вызвать OpenGL-команды}
\pause
\item В реальности драйвер поставил их в очередь, и скорее всего GPU ещё не начала их выполнять
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Измерение времени работы \textendash{} простой способ}
\begin{verbatim}
disableVsync();
auto last_frame_start = clock::now();
while (true) {
  auto frame_start = clock::now();
  auto frame_time = frame_start - last_frame_start;
  last_frame_start = frame_start;

  // нарисовали сцену
  ...

  SwapBuffers();
}
\end{verbatim}
\pause
\begin{itemize}
\item Из-за выключенного vsync видеокарта будет работать \begin{math}\pm\end{math} постоянно
\pause
\item В итоге мы получим примерное время, тратящееся на рисование одного кадра
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Измерение времени работы: glFlush и glFinish}
\begin{itemize}
\item Многие (старые) туториалы по измерению времени кадра советуют вызывать \verb|glFlush| или \verb|glFinish| в конце кадра
\pause
\item \verb|glFlush| сбрасывает буфер команд (хранящийся внутри драйвера) с CPU на GPU
\pause
\item \verb|glFinish| ждёт, пока GPU не завершит обрабатывать все посланные команды
\pause
\item \verb|SwapBuffers| сама вызывает \verb|glFlush|
\pause
\item \verb|glFinish| ухудшает производительность: половину времени вы отправляете команды на GPU, а GPU (скорее всего) ничего не делает; половину времени вы ждёте, пока GPU закончит выполнять команды
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Измерение времени работы: FPS vs frame duration}
\begin{itemize}
\item FPS (frames per second, количество кадров в секунду) \textendash{} очень неудобная метрика:
\pause
\begin{itemize}
\item Нелинейна: если кадр рисовался 10 мс, и мы добавили что-то рисующееся 1 мс, и ещё что-то рисующееся 1 мс, то FPS изменялся от 100 до 90.9 до 83.3
\end{itemize}
\pause
\item Обычно используют время, тратящееся на рисование кадра или конкретного объекта/эффекта (миллисекунды/микросекунды)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Измерение времени работы \textendash{} правильный способ: timer queries}
\begin{itemize}
\item Query objects \textendash{} объекты OpenGL, позволяющие узнать некоторую статистику с GPU:
\pause
\begin{itemize}
\item Сколько было нарисовано пикселей
\pause
\item Сколько сгенерировано примитивов (геометрическим шейдером)
\pause
\item Сколько прошло времени
\end{itemize}
\pause
\item \verb|glGenQueries/glDeleteQueries|
\pause
\item \textbf{Нет} \verb|glBindQuery|!
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Измерение времени работы \textendash{} правильный способ: timer queries}
\begin{itemize}
\item \verb|glBeginQuery/glEndQuery| \textendash{} статистика будет собрана для команд между этими вызовами
\pause
\item \textbf{Не могут} быть вложенными
\end{itemize}
\pause
\begin{verbatim}
GLuint query_id;
glGenQueries(1, &query_id);

...

glBegin(GL_TIME_ELAPSED, query_id);

// что-нибудь рисуем

glEnd(GL_TIME_ELAPSED);
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Измерение времени работы \textendash{} правильный способ: timer queries}
\begin{itemize}
\item GPU работает асинхронно \begin{math}\Rightarrow\end{math} результат query будет готов не сразу
\pause
\item Узнать, готов ли результат:
\begin{verbatim}
glGetQueryObjectiv(query_id,
  GL_QUERY_RESULT_AVAILABLE, &result);
\end{verbatim}
\pause
\item Получить результат (блокирует поток, если результат ещё не готов; неявно вызывает \verb|glFlush|)
\begin{verbatim}
glGetQueryObjectiv(query_id,
  GL_QUERY_RESULT, &result);
\end{verbatim}
\pause
\item Время возвращается в \textbf{наносекундах}, т.е. знаковый 32-битный тип может представить 2 секунды
\pause
\item Если 64-битные и беззнаковые версии этих функций
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Измерение времени работы \textendash{} правильный способ: пул timer queries}
\begin{itemize}
\item Хотим мерять время рисования каждого кадра, но результат для предыдущего кадра может быть не готов к началу следующего кадра
\pause
\item \begin{math}\Rightarrow\end{math} Заводим пул (pool) query-объектов:
\pause
\begin{itemize}
\item Храним расширяемый массив (\verb|std::vector|) query-объектов: ID + свободен или нет
\pause
\item Когда нам нужен новый query, ищем в массиве свободный объект, если такого нет - добавляем новый
\pause
\item В конце рисования кадра проходим по всем несвободным объектам и проверяем: если результат уже готов, обрабатываем его и помечаем объект свободным
\end{itemize}
\pause
\item Средний размер пула \textendash{} на сколько кадров отстаёт GPU от CPU
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Timer queries: ссылки}
\begin{itemize}
\item \href{https://www.khronos.org/opengl/wiki/Query_Object}{khronos.org/opengl/wiki/Query\_Object}
\item \href{https://www.lighthouse3d.com/tutorials/opengl-timer-query}{Туториал по использованию timer queries}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Поиск bottleneck'а}
\begin{itemize}
\item Мы знаем, что что-то тормозит
\pause
\item OpenGL pipeline включает много компонентов, какой именно тормозит?
\pause
\item Обычно компоненты конвейера влияют на следующие за ними компоненты
\pause
\begin{itemize}
\item Больше вершин \begin{math}\Rightarrow\end{math} больше вызовов вершинного шейдера
\item Больше примитивов \begin{math}\Rightarrow\end{math} больше пикселей
\item Больше пикселей \begin{math}\Rightarrow\end{math} больше вызовов фрагментного шейдера
\item Больше пикселей \begin{math}\Rightarrow\end{math} больше операций записи в память
\end{itemize}
\pause
\item Удобно искать bottleneck с конца конвейера
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\fontsize{10pt}{10pt}
\frametitle{Поиск bottleneck'а}
\begin{itemize}
\item Упростим до предела фрагментный шейдер (напр. выведем фиксированный цвет)
\pause
\begin{itemize}
\item Стало лучше? \begin{math}\Rightarrow\end{math} Слишком тяжёлый фрагментный шейдер
\end{itemize}
\pause
\item Уменьшим размер окна до чего-нибудь в духе 50x50 пикселей
\pause
\begin{itemize}
\item Стало лучше? \begin{math}\Rightarrow\end{math} Слишком много операций записи в память
\end{itemize}
\pause
\item Упростим до предела вершинный шейдер (напр. вернём фиксированные координаты)
\pause
\begin{itemize}
\item Стало лучше? \begin{math}\Rightarrow\end{math} Слишком тяжёлый фрагментный шейдер
\end{itemize}
\pause
\item Уменьшим число вершин (параметр \verb|count| в \verb|glDraw*|)
\pause
\begin{itemize}
\item Стало лучше? \begin{math}\Rightarrow\end{math} Слишком много вершин
\end{itemize}
\pause
\item Ничего не помогло \begin{math}\Rightarrow\end{math} CPU-bound
\pause
\begin{itemize}
\item Слишком много OpenGL-вызовов
\pause
\item Слишком много других операций на CPU
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\fontsize{10pt}{10pt}
\frametitle{Оптимизация шейдеров}
\begin{itemize}
\item Выполняем меньше операций
\pause
\item Избегаем вызова сложных функций (\verb|sin|, \verb|exp|, \verb|pow|)
\pause
\item Реорганизуем вычисления (напр. \verb|exp(a+b+c+d)| вместо \verb|exp(a)*exp(b)*exp(c)*exp(d)|)
\pause
\item Предпосчитываем что-нибудь (в константный массив в шейдере или в текстуру)
\pause
\item Меньше читаем из текстур
\pause
\item Читаем из текстур меньшего размера (лучше утилизируется текстурный кэш)
\pause
\item Близкие пиксели читают близкие части текстуры (лучше утилизируется текстурный кэш)
\pause
\item Используем mipmap'ы
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Оптимизация числа вершин}
\begin{itemize}
\item Используем индексированный рендеринг (меньше данных нужно прочитать из памяти; лучше используется вершинный кэш)
\pause
\item Используем примитивы, группирующие вершины \textendash{} line strip, triangle strip, triangle fan, etc (те же причины)
\pause
\item Используем LOD (level of detail)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Оптимизация количества OpenGL-вызовов}
\begin{itemize}
\item Batching: группируем объекты по используемому шейдеру, текстуре, другим настройкам (меньше переключения состояния OpenGL \begin{math}\Rightarrow\end{math} меньше OpenGL-вызовов)
\pause
\item Instancing: рисуем много объектов одним OpenGL-вызовом
\pause
\item Uniform buffers: передаём uniform-переменные не по одной, а записываем их в буффер (вместо большого количества вызовов \verb|glUniform*| один вызов \verb|glBufferData|)
\pause
\item Indirect rendering: переносим вычисления того, что нужно нарисовать, на GPU (OpenGL 4.0 + compute shaders)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Оптимизация чего угодно}
\begin{itemize}
\item Рисуем поменьше
\begin{itemize}
\item Frustum culling: не рисуем то, что не попадёт в камеру
\pause
\item Occlusion culling: не рисуем то, чего не видно (закрыто другими объектами)
\end{itemize}
\pause
\item Переводим рисование в отдельный поток
\begin{itemize}
\item Освобождает основной (UI) поток
\pause
\item Позволяет делать полезную работу, пока render-поток ждёт VSync
\pause
\item Сильно усложняет код
\pause
\item Все OpenGL-вызовы нужно делать из render-потока
\pause
\item Применяется только в крайних случаях
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Оптимизация: ссылки}
\begin{itemize}
\item \href{https://www.khronos.org/opengl/wiki/Performance}{khronos.org/opengl/wiki/Performance}
\item \href{https://www.opengl.org/pipeline/article/vol003_8}{opengl.org/pipeline/article/vol003\_8}
\item \href{https://www.nvidia.com/docs/IO/8230/GDC2003_OGL_Performance.pdf}{Доклад с GDC 2003, всё ещё актуальный}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\fontsize{10pt}{10pt}
\frametitle{LOD (level of detail)}
\begin{itemize}
\item Когда модель далеко от камеры, рисуем упрощённую модель вместо детализированной
\pause
\item Таких уровней детализации может быть несколько, вплоть до почти непрерывного изменения детализации (Unreal 5 Nanite)
\pause
\item Упрощённая модель может иметь отдельные VAO/VBO/EBO, а может лежать вместе с основной моделью (рисование конкретного LOD'а сводится к передаче правильных \verb|first| и \verb|count| в \verb|glDrawArrays| и т.п.)
\pause
\item Автоматическая генерация упрощённой модели \textendash{} предмет активных исследований
\begin{itemize}
\item Большинство современных подходов используют edge collapse: пара вершин, соединённых ребром, схлопывается в одну вершину
\end{itemize}
\pause
\item Конкретный уровень детализации выбирается на основе желаемого видимого размера треугольников
\pause
\item Выбор уровня детализации можно перенести на GPU (indirect rendering)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Batching}
\begin{itemize}
\item Может быть неявным: объекты, использующие один шейдер/материал/etc сами по себе лежат в одном месте
\pause
\item Может быть явным: движок рендеринга получает список объектов и сам их сортирует
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\fontsize{10pt}{10pt}
\frametitle{Instanced rendering (instancing)}
\begin{itemize}
\item Позволяет рисовать несколько копий (instances) объекта одним OpenGL-вызовом
\pause
\item Обычно атрибуты вершин берутся в соответствии с индексом вершины: \verb|offset + stride * vertexID|
\pause
\item При использовании instancing конкретный атрибут вычисляется из номера instance: \verb|offset + stride * (instanceID / divisor)| (целочисленное деление)
\pause
\item Включить instancing для конкретного атрибута: \verb|glVertexAttribDivisor(index, divisor)|:
\begin{itemize}
\item \verb|divisor = 0|: атрибут не использует instancing и использует номер вершины
\item \verb|divisor != 0|: атрибут использует instancing и использует номер instance (по формуле выше)
\end{itemize}
\pause
\item Вызвать instanced rendering: \verb|glDrawArraysInstanced|
\begin{itemize}
\item Параметры \textendash{} те же, что у \verb|glDrawArrays|, плюс последний параметр \textendash{} количество instance'ов (значения \verb|instanceID| будут в диапазоне \verb|0 .. isntance_count-1|)
\end{itemize}
\pause
\item Аналогично есть \verb|glDrawElementsInstanced|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Instancing: ссылки}
\begin{itemize}
\item \href{https://www.khronos.org/opengl/wiki/Vertex_Rendering#Instancing}{khronos.org/opengl/wiki/Vertex\_Rendering\#Instancing}
\item \href{https://learnopengl.com/Advanced-OpenGL/Instancing}{learnopengl.com/Advanced-OpenGL/Instancing}
\item \href{https://ogldev.org/www/tutorial33/tutorial33.html}{ogldev.org/www/tutorial33/tutorial33.html}
\item \href{https://habr.com/ru/post/352962}{habr.com/ru/post/352962}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Uniform buffers}
\begin{itemize}
\item Позволяет использовать в качестве uniform-переменных данные из буфера
\pause
\item Специальный тип (target) для буферов: \verb|GL_UNIFORM_BUFFER| (создание и загрузка данных \textendash{} так же, как для других буферов)
\pause
\item В шейдере \textendash{} т.н. \textit{buffer-backed interface block}
\pause
\item Нужно быть внимательным с memory layout данных в буфере (конкретные правила описаны в спецификации)
\pause
\item Каждый interface block нужно привязать к \textit{binding index}: \verb|glGetUniformBlockIndex + glUniformBlockBinding| (в OpenGL 4.2 можно задать прямо в шейдере)
\item Uniform buffer нужно привизать к тому же \textit{binding index}: \verb|glBindBufferBase| или \verb|glBindBufferRange|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\fontsize{10pt}{10pt}
\frametitle{Uniform buffers: ссылки}
\begin{itemize}
\item \href{https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object}{khronos.org/opengl/wiki/Uniform\_Buffer\_Object}
\item \href{https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Buffer_backed}{khronos.org/opengl/wiki/Interface\_Block\_(GLSL)\#Buffer\_backed}
\item \href{https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL}{learnopengl.com/Advanced-OpenGL/Advanced-GLSL}
\end{itemize}
\end{frame}

\end{document}