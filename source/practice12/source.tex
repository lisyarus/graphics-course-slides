% (c) Nikita Lisitsa, lisyarus@gmail.com, 2022

\documentclass{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{adjustbox}

\usepackage{color}
\usepackage{soul}

\usepackage{hyperref}

\definecolor{blue}{rgb}{0,0,1}
\definecolor{red}{rgb}{1,0,0}

\makeatletter
\newcommand{\slideimage}[1]{
  \begin{figure}
    \begin{adjustbox}{width=\textwidth, totalheight=\textheight-2\baselineskip-2\baselineskip,keepaspectratio}
      \includegraphics{#1}
    \end{adjustbox}
  \end{figure}
}
\makeatother

\title{Компьютерная графика}
\subtitle{Практика 12: Volume rendering}
\date{2022}

\setbeamertemplate{footline}[frame number]

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
\slideimage{0.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 1}
Находим пересечение с AABB объекта (во фрагментном шейдере)
\begin{itemize}
\item Вычисляем \textbf{нормированный} вектор направления из камеры в текущую точку поверхности -- это вектор направления луча
\item Вычисляем пересечение этого луча с AABB: интервал \begin{math}[t_{min}, t_{max}]\end{math} для которых \begin{math}p + t \cdot d\end{math} содержится в AABB (в коде уже есть функция \verb|intersect_bbox|, возвращает \verb|vec2(tmin, tmax)|)
\item Делаем \verb|tmin = max(tmin, 0.0)|, чтобы не включать часть пересечения сзади камеры
\item В качестве цвета пикселя выводим \verb|vec3(tmax - tmin)| (это значение часто будет больше единицы, так что можно разделить, например, на 4.0)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\slideimage{1.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 2}
Вычисляем optical depth куба (во фрагментном шейдере)
\begin{itemize}
\item Заводим константу для коэффициента поглощения: \verb|absorption = 1.0|
\item Вычисляем optical depth: \verb|optical_depth = (tmax - tmin) * absorption|
\item Вычисляем непрозрачность пикселя: \verb|opacity = 1.0 - exp(-optical_depth)|
\item Записываем значение opacity в альфа-канал результирующего цвета (RGB-каналы заполните вашим любимым цветом)
\item Можно поиграться со значением \verb|absorption| чтобы понять, как оно влияет на результат
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\slideimage{2.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 3}
\fontsize{8pt}{8pt}\selectfont
Загружаем 3D текстуру
\begin{itemize}
\item Создаём текстуру типа \verb|GL_TEXTURE_3D|, min/mag фильтры -- \verb|GL_LINEAR|
\item Устанавливаем параметры \verb|WRAP_R|, \verb|WRAP_S|, \verb|WRAP_T| в \verb|GL_CLAMP_TO_EDGE|
\item Считываем данные из файла \verb|cloud_data_path| (128x64x64, одноканальная, 1 байт на пиксель):
\begin{itemize}
\fontsize{8pt}{8pt}\selectfont
\item Заводим \verb|std::vector<char> pixels(...)| нужного размера
\item Открываем файл \verb|std::ifstream input(path, std::ios::binary)|
\item Читаем данные \verb|input.read(pixels.data(), pixels.size())|
\end{itemize}
\item Загружаем в текстуру с помощью \verb|glTexImage3D| (internal format -- \verb|GL_R8|, format -- \verb|GL_RED|, type -- \verb|GL_UNSIGNED_BYTE|)
\item Добавляем текстуру в шейдер (\verb|uniform sampler3D|), выводим в качестве цвета значение из текстуры в точке \verb|p = camera_position + direction * (tmin + tmax) / 2.0|
\begin{itemize}
\fontsize{8pt}{8pt}\selectfont
\item Нужно перевести пространственные координаты в текстурные: \verb|(p - bbox_min) / (bbox_max - bbox_min)|
\item Удобно завести функцию, возвращающую значение из текстуры по точке в пространстве
\end{itemize}
\item В качестве альфа-канала возьмём 1, иначе ничего не увидим
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 3}
N.B. можно взять другую текстуру: \verb|bunny.data| (есть в репозитории с заданием)
\begin{itemize}
\item Размер -- 64x64x64
\item \verb|bbox_min = vec3(-1, -1, -1)|
\item \verb|bbox_max = vec3( 1,  1,  1)|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\slideimage{3.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 4}
Вычисляем optical depth с помощью front-to-back алгоритма (во фрагментном шейдере)
\begin{itemize}
\item Инициализируем \verb|optical_depth = 0|
\item Делаем цикл, например, в 64 шага; один шаг цикла соответствует 1/64 части отрезка \verb|dt = (tmax - tmin) / 64|
\begin{itemize}
\item Вместо 64 можно взять любое другое число; чем больше, тем красивее и медленнее
\item Каждой итерации \verb|i| цикла соответвует значение \verb|t = tmin + (i + 0.5) * dt|
\item Каждому значению \verb|t| соответствует точка луча \verb|p = camera_position + t * direction|
\item Берём плотность из текстуры в текущей точке \verb|p|
\item Обновляем optical depth: \verb|optical_depth += absorption * density * dt|
\end{itemize}
\item Вычисляем opacity как в задании 2
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\slideimage{4.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 5}
\fontsize{8pt}{8pt}\selectfont
Вычисляем рассеяние (во фрагментном шейдере), считаем что фазовая функция не зависит от угла рассеяния (тогда \begin{math}f(p,\theta) = \frac{1}{4\pi}\end{math})
\begin{itemize}
\item Коэффициент поглощения можно сделать поменьше (или даже нулём)
\item Заводим коэффициенты рассеяния \verb|scattering = 4.0| и вымирания \verb|extinction = absorption + scattering|
\item Заводим интенсивность света \verb|light_color = vec3(16.0)|
\item Инициализируем рассеянный свет \verb|color = vec3(0.0)|
\item В цикле аккумулируем и optical depth, и рассеянный свет
\item \verb|optical_depth += extinction * density * dt|
\item Для рассеяния нужно посчитать \verb|light_optical_depth| аналогичным вложенным циклом (число итераций может быть другое, например 16) вдоль луча из текущей точки в направлении света \verb|light_direction|
\begin{itemize}
\fontsize{8pt}{8pt}\selectfont
\item Придётся вызвать \verb|intersect_bbox| на каждую итерацию внешнего цикла
\item Придётся читать из текстуры на каждую итерацию внутреннего цикла
\end{itemize}
\item Обновляем рассеянный свет как \begin{verbatim}color += light_color * exp(-light_optical_depth) * exp(-optical_depth)
    * dt * density * scattering / 4.0 / PI\end{verbatim}
\item В качестве результата шейдера выводим \verb|vec4(color, alpha)|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\slideimage{5.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 6*}
Разные коэффициенты рассеяния для разных цветов
\begin{itemize}
\item Обычный блендинг не умеет делать альфа-канал для каждого цвета по отдельности, так что заменим цвет фона (\verb|glClearColor|) на чёрный
\item Коэффициенты \verb|absorption|, \verb|scattering|, \verb|extinction|, а также величины \verb|optical_depth| и \verb|light_optical_depth| должны стать \verb|vec3|
\item В координаты \verb|scattering| нужно записать три разных числа (подберите что-нибудь сами в районе 1..10)
\item Поиграйтесь со значением \verb|scattering|, чтобы посмотреть, как оно влияет на результат
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\slideimage{6.png}
\end{frame}

\end{document}