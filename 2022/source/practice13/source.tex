% (c) Nikita Lisitsa, lisyarus@gmail.com, 2022

\documentclass{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{adjustbox}

\usepackage{color}
\usepackage{soul}

\usepackage{hyperref}

\definecolor{blue}{rgb}{0,0,1}
\definecolor{red}{rgb}{1,0,0}

\makeatletter
\newcommand{\slideimage}[1]{
  \begin{figure}
    \begin{adjustbox}{width=\textwidth, totalheight=\textheight-2\baselineskip-2\baselineskip,keepaspectratio}
      \includegraphics{#1}
    \end{adjustbox}
  \end{figure}
}
\makeatother

\title{Компьютерная графика}
\subtitle{Практика 13: Скелетная анимация}
\date{2022}

\setbeamertemplate{footline}[frame number]

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
\slideimage{0.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 1}
Проверяем, что нормально заданы веса вершин
\begin{itemize}
\item В вершинном шейдере добавляем два новых атрибута вершин:
\begin{itemize}
\item Номера костей для вершины: \verb|ivec4 in_joints|, \verb|location = 3|
\item Веса костей для вершины: \verb|vec4 in_weights|, \verb|location = 4|
\item (в VAO эти атрибуты уже настроены)
\end{itemize}
\item Передаём \verb|in_weights| во фрагментный шейдер и используем в качестве цвета
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 1}
\slideimage{1.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 2}
\fontsize{8pt}{8pt}
\selectfont
Применяем преобразования костей
\begin{itemize}
\item Возвращаем нормальное вычисление цвета во фрагментном шейдере
\item В вершинном шейдере: заводим uniform-массив для матриц костей \verb|uniform mat4x3 bones[64]|
\begin{itemize}
\fontsize{8pt}{8pt}
\selectfont
\item Location получаем как \verb|glGetUniformLocation(program, "bones")|
\end{itemize}
\item Вычисляем взвешенное среднее \verb|mat4x3 average| матриц для вершины (\verb|in_joints| -- индексы четырёх матриц, \verb|in_weights| -- их веса)
\item Перед применением матрицы \verb|model| применяем к входной вершине матрицу \verb|mat4(average)|
\item Перед применением матрицы \verb|mat3(model)| применяем к входной нормали матрицу \verb|mat3(average)|
\item В цикле рендеринга заводим переменную \verb|scale| как-то меняющуюся со временем (например, \verb|0.75 + cos(time) * 0.25|)
\item В цикле рендеринга заводим массив матриц \verb|std::vector<glm::mat4x3>| размера \verb|input_model.bones.size()| и заполняем значением \verb|glm::mat4x3(scale)|
\item Передаём матрицы в uniform-массив одним вызовом \verb|glUniformMatrix4x3fv|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 2}
\slideimage{2.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 3}
\fontsize{8pt}{8pt}
\selectfont
Вычисляем преобразования костей
\begin{itemize}
\item Достаём из входной модели анимацию с названием \verb|"01_Run"|
\item Для каждой кости \verb|i| вычисляем её преобразование: \verb|glm::mat4 transform = translation * rotation * scale|
\begin{itemize}
\fontsize{8pt}{8pt}
\selectfont
\item \verb|translation| берётся из \verb|animation.bones[i].translation(0.f)| (0 -- время кадра, пока про него не думаем), остальные компоненты аналогично
\item Получить по \verb|translation| матрицу можно через \verb|glm::translate(glm::mat4(1.f), translation)|, аналогично \verb|glm::scale| для \verb|scale|
\item Получить по кватерниону \verb|rotation| матрицу можно через \verb|glm::toMat4|
\item Если у кости есть родитель \verb|input_model.bones[i].parent|, домножаем матрицу \verb|transform| на матрицу родителя: \verb|parent_transform * transform|
\item Записываем \verb|transform| в \verb|bones[i]| (в этот момент \verb|mat4| конвертируется в \verb|mat4x3|)
\end{itemize}
\item После этого отдельным циклом домножаем каждую кость на её inverse-bind матрицу: \verb|bones[i] = bones[i] * input_model.bones[i].inverse_bind_matrix|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 3}
\slideimage{3.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 4}
Анимируем модель
\begin{itemize}
\item Вместо значения 0, передаваемого в \verb|animation.bones[i].translation(...)| и т.п., передаём значение \verb|std::fmod(time, animation.max_time)|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 4}
\slideimage{4.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 5*}
Интерполируем между двумя анимациями
\begin{itemize}
\item Заводим некий параметр интерполяции, который
\begin{itemize}
\item Линейно растёт (\verb|... += speed * dt|), если нажата какая-то клавиша (например, \verb|SDLK_LSHIFT| -- левый shift)
\item Линейно убывает (\verb|... -= speed * dt|), если эта клавиша не нажата
\item После обновления параметр ограничивается диапазоном [0, 1]
\end{itemize}
\item Используем этот параметр для интерполяции между анимациями \verb|"01_Run"| и \verb|"02_walk"|:
\begin{itemize}
\item Для \verb|translation| каждой кости интерполируем (\verb|glm::lerp|) между \verb|walk_animation.bones[i].translation| и \verb|run_animation.bones[i].translation|
\item Аналогично для \verb|rotation| и \verb|scale| (для вращения лучше использовать \verb|glm::slerp|)
\end{itemize}
\item N.B. \verb|max_time| у этих двух анимаций разный!
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Задание 5*}
\slideimage{5.png}
\end{frame}

\end{document}