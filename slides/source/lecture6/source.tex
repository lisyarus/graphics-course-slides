% (c) Nikita Lisitsa, lisyarus@gmail.com, 2021

\documentclass{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{adjustbox}

\usepackage{color}
\usepackage{soul}

\usepackage{hyperref}

\usepackage{tikz}
\usetikzlibrary{decorations}
\usetikzlibrary{decorations.pathreplacing}
\usepackage{xifthen}

\definecolor{red}{rgb}{1,0,0}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{blue}{rgb}{0,0,1}
\definecolor{magenta}{rgb}{0.75,0,0.75}

\makeatletter
\newcommand{\slideimage}[1]{
  \begin{figure}
    \begin{adjustbox}{width=\textwidth, totalheight=\textheight-2\baselineskip-2\baselineskip,keepaspectratio}
      \includegraphics{#1}
    \end{adjustbox}
  \end{figure}
}
\makeatother

\title{Компьютерная графика}
\subtitle{Лекция 6: Ошибки OpenGL, расширения OpenGL, blending, освещение}
\date{2021}

\setbeamertemplate{footline}[frame number]

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
\frametitle{Ошибки OpenGL}
\begin{itemize}
\item Часто драйвер может понять, что в определённом OpenGL-вызове содержится ошибка
\pause
\begin{itemize}
\item \verb|glTexImage2D| с параметром \verb|target|, не являющимся одним из типов текстур
\pause
\item \verb|glTexParameteri| устанавливающая mag filter в что-то отличное от \verb|GL_LINEAR| или \verb|GL_NEAREST|
\pause
\item \verb|glBindBuffer| с ID буффера, который не был получен через \verb|glGenBuffers|
\pause
\item etc.
\end{itemize}
\pause
\item В таких случаях генерируется ошибка как особое значение типа \verb|GLenum|
\pause
\item Как правило, вызвавшая ошибку операция не выполняется
\pause
\item \verb|glGetError()| - получить значение ошибки, если она была
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Ошибки OpenGL}
Возможные значения ошибок:
\begin{itemize}
\item \verb|GL_NO_ERROR| - ошибки нет
\pause
\item \verb|GL_INVALID_ENUM| - недопустимое значения перечисления (например, \verb|GL_TEXTURE_2D| как первый параметр \verb|glBindBuffer|)
\pause
\item \verb|GL_INVALID_VALUE| - недопустимое значение числового аргумента (например, отрицательная ширина текстуры в \verb|glTexImage2D|)
\pause
\item \verb|GL_INVALID_OPERATION| - недопустимая операция (например, \verb|glUniform1i| при отсутствии текущей шейдерной программы)
\pause
\item \verb|GL_INVALID_FRAMEBUFFER_OPERATION| - операция рисования/чтения пикселей с невалидным framebuffer'ом (о них мы поговорим позже)
\pause
\item \verb|GL_OUT_OF_MEMORY| - закончилась память на GPU (может быть вызвана любой OpenGL-командой, обычно не обрабатывается)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Ошибки OpenGL}
\begin{itemize}
\item Документация к каждой функции описывает все возможные ошибки, которые эта функция может вызвать, и в каких случаях
\pause
\begin{itemize}
\item N.B. \verb|GL_OUT_OF_MEMORY| нигде не указан, потому что может появиться где угодно
\end{itemize}
\pause
\item Не все ошибки покрываются этим механизмом (например: \verb|glDrawArrays| с правильно настроенным VAO но с пустым VBO с вершинами)
\pause
\item Нет информации о том, какая именно функция вызвала ошибку (любая из тех, что были вызваны до \verb|glGetError|)
\pause
\begin{itemize}
\item \begin{math}\Rightarrow\end{math} Придётся расставлять проверку после каждого OpenGL-вызова
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Ошибки OpenGL}
\begin{itemize}
\item Драйвер может хранить один флаг ошибки, и пропускать все последующие ошибки до вызова \verb|glGetError|
\pause
\item Драйвер может хранить несколько флагов, и \verb|glGetError| возвращает и очищает любой из них
\pause
\item \begin{math}\Rightarrow\end{math} Чтобы очистить ошибки, нужно вызывать \verb|glGetError| в цикле:
\end{itemize}
\begin{verbatim}
while (glGetError() != GL_NO_ERROR);
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Ошибки OpenGL}
\begin{itemize}
\item OpenGL 4.3+ (или расширение \verb|GL_ARB_debug_output|): более удобный механизм, \verb|glDebugMessageCallback|
\pause
\item \href{https://www.khronos.org/opengl/wiki/OpenGL_Error}{khronos.org/opengl/wiki/OpenGL\_Error}
\item \href{https://docs.gl/gl3/glGetError}{docs.gl/gl3/glGetError}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Расширения OpenGL}
\begin{itemize}
\item Предоставляют дополнительную функциональность за рамками возможностей конкретной версии OpenGL\only<2->{, например}
\pause
\begin{itemize}
\item Конкретный производитель выпустил новую функциональность
\pause
\item Фунцкиональность доступна на большинстве реализаций OpenGL, но ещё не успела войти в новую версию OpenGL
\pause
\item Функциональность доступна в новой версии OpenGL, но крайне распространена и хочется ей пользоваться из старой версии
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Расширения OpenGL}
\begin{itemize}
\item Делятся на
\begin{itemize}
\item ARB (\textit{Architectural Review Board}) - функциональность, которая (скорее всего) войдёт в следующий стандарт
\item EXT - широко распространённая функциональность
\item NV - расширение от Nvidia (возможно, доступно и на других видеокартах)
\item AMD - расширение от AMD (возможно, доступно и на других видеокартах)
\item APPLE - расширение от APPLE (возможно, доступно и на других видеокартах)
\item И т.д.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Расширения OpenGL}
\begin{itemize}
\item Расширение - набор констант и функций (как и конкретная версия OpenGL)
\pause
\item Функции нужно загружать, так же, как и функции самого OpenGL
\pause
\item Константы и перечисления заканчиваются на суффикс в зависимости от типа расширения:
\begin{itemize}
\item \verb|ARB_debug_output|: \verb|glDebugMessageCallbackARB|, \verb|GL_DEBUG_SEVERITY_HIGH_ARB|
\item \verb|EXT_texture_filter_anisotropic|: \verb|GL_TEXTURE_MAX_ANISOTROPY_EXT|
\item \verb|NV_texture_barrier|: \verb|glTextureBarrierNV|
\end{itemize}
\pause
\item Исключение: core extensions - предоставляют функциональность новых версий OpenGL в старых версиях OpenGL
\begin{itemize}
\item Имеют тип \verb|ARB|
\item Не имеют суффиксов в названиях функций и констант
\end{itemize}  
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Расширения OpenGL}
\begin{itemize}
\item Получить список поддерживаемых расширений:
\end{itemize}
\begin{verbatim}
GLint numExtensions;
glGetIntegerv(GL_NUM_EXTENSIONS, numExtensions);
for (GLint i = 0; i < numExtensions; ++i) {
    std::cout << glGetStringi(GL_EXTENSIONS, i) << "\n";
}
\end{verbatim}
\pause
\begin{itemize}
\item GLEW загружает их автоматически:
\end{itemize}
\begin{verbatim}
if (GLEW_EXT_texture_filter_anisotropic) {
    std::cout << "Anisotropic filtering is supported\n";
}
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Расширения OpenGL}
\begin{itemize}
\item \href{https://www.khronos.org/opengl/wiki/OpenGL_Extension}{khronos.org/opengl/wiki/OpenGL\_Extension}
\item \href{https://www.khronos.org/registry/OpenGL/index_gl.php}{khronos.org/registry/OpenGL/index\_gl.php} - список всех зарегистрированных расширений
\end{itemize}
\end{frame}

\begin{frame}<1-3>[fragile,label=blending]
\frametitle{Blending (смешивание)}
\begin{itemize}
\item Результат фрагментного шейдера (\verb|layout (location = 0) vec4 out_color;|) записывается в пиксель экрана, стирая то, что было в нём до этого
\pause
\item Иногда мы хотим "смешать" результат и пиксель экрана, и записать результат смешивания
\pause
\begin{itemize}
\item Полупрозрачные объекты
\pause
\item Растительность
\pause
\item Алгоритмы освещения и теней
\pause
\item Heatmaps
\pause
\item Ручное сглаживание
\pause
\item И т.д.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Полупрозрачность}
\begin{figure}
\slideimage{window.png}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Полупрозрачность}
\begin{figure}
\slideimage{macos-ui.png}
\end{figure}
\end{frame}

\againframe<3-4>{blending}

\begin{frame}
\frametitle{Деревья}
\begin{figure}
\slideimage{birch.png}
\end{figure}
\end{frame}

\againframe<4-6>{blending}

\begin{frame}
\frametitle{Heatmap}
\begin{figure}
\slideimage{heatmap.jpg}
\end{figure}
\end{frame}

\againframe<6-7>{blending}

\begin{frame}
\frametitle{Yandex maps}
\begin{figure}
\slideimage{yandex-maps.jpg}
\end{figure}
\end{frame}

\againframe<7->{blending}

\begin{frame}[fragile]
\frametitle{Blending (смешивание)}
\begin{itemize}
\item Включается/выключается: \verb|glEnable(GL_BLEND)|
\pause
\item \begin{math}src\end{math} - результат фрагментного шейдера
\item \begin{math}dst\end{math} - пиксель на экране
\item Уравнение blending'а:
\begin{center}
\begin{math}
dst \leftarrow f(C_{src} \cdot src, C_{dst} \cdot dst)
\end{math}
\end{center}
\pause
\item \begin{math}f\end{math} - настраиваемая функция
\item \begin{math}C_{src}\end{math} и \begin{math}C_{dst}\end{math} - настраиваемые веса
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Blending (смешивание)}
\begin{itemize}
\item Настройка функции \begin{math}f\end{math}: \verb|glBlendEquation(GLenum equation)|:
\pause
\begin{itemize}
\item \verb|GL_FUNC_ADD|: \begin{math}f(src, dst) = src + dst\end{math}
\item \verb|GL_FUNC_SUBTRACT|: \begin{math}f(src, dst) = src - dst\end{math}
\item \verb|GL_FUNC_REVERSE_SUBTRACT|: \begin{math}f(src, dst) = dst - src\end{math}
\item \verb|GL_MIN|: \begin{math}f(src, dst) = \min(src, dst)\end{math}
\item \verb|GL_MAX|: \begin{math}f(src, dst) = \max(src, dst)\end{math}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Blending (смешивание)}
\begin{itemize}
\item Настройка весов \begin{math}C_{src}\end{math} и \begin{math}C_{dst}\end{math}: \verb|glBlendFunc(GLenum src, GLenum dst)|:
\pause
\begin{itemize}
\item \verb|GL_ZERO|: \begin{math}C = 0\end{math}
\item \verb|GL_ONE|: \begin{math}C = 1\end{math}
\item \verb|GL_SRC_COLOR|: \begin{math}C = src\end{math}
\item \verb|GL_ONE_MINUS_SRC_COLOR|: \begin{math}C = 1 - src\end{math}
\item \verb|GL_SRC_ALPHA|: \begin{math}C = src_A\end{math}
\item \verb|GL_ONE_MINUS_SRC_ALPHA|: \begin{math}C = 1 - src_A\end{math}
\item И т.д.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Blending (смешивание)}
\begin{itemize}
\item Обычно \begin{math}src=(R,G,B,A)\end{math} означает, что цвет имеет полупрозрачность \begin{math}A\end{math}
\begin{itemize}
\item \begin{math}A=0\end{math} - полностью прозрачный цвет
\item \begin{math}A=1\end{math} - полностью непрозрачный цвет
\end{itemize}
\pause
\item Для этого нужна такая формула смешивания:
\begin{center}
\begin{math}
dst \leftarrow src_A \cdot src + (1 - src_A) \cdot dst
\end{math}
\end{center}
\pause
\item Этому соответстует настройка
\begin{verbatim}
glBlendEquation(GL_FUNC_ADD);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
\end{verbatim}
\pause
\item Это самый типичный способ использовать blending
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Blending (смешивание)}
\begin{itemize}
\item Такое смешивание некоммутативно, т.е. результат зависит от порядка рисования
\end{itemize}
\slideimage{two-squares.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Blending (смешивание)}
\begin{itemize}
\item Смешивание некорректно работает с тестом глубины
\end{itemize}
\slideimage{blending_incorrect_order.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Blending (смешивание)}
\begin{itemize}
\item В общем случае нужно сортировать полупрозрачные объекты и рисовать в порядке уменьшения расстояния до камеры
\item Order-independent transparency (OIT) - активная тема исследований
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Blending (смешивание)}
\slideimage{blending_sorted.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Blending (смешивание)}
\begin{itemize}
\item \href{https://www.khronos.org/opengl/wiki/Blending}{khronos.org/opengl/wiki/Blending}
\item \href{http://docs.gl/gl3/glBlendFunc}{docs.gl/gl3/glBlendFunc}
\item \href{http://docs.gl/gl3/glBlendEquation}{docs.gl/gl3/glBlendEquation}
\item \href{http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-10-transparency/}{opengl-tutorial.org/intermediate-tutorials/tutorial-10-transparency}
\item \href{https://learnopengl.com/Advanced-OpenGL/Blending}{learnopengl.com/Advanced-OpenGL/Blending}
\end{itemize}
\end{frame}

\end{document}