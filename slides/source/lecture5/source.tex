% (c) Nikita Lisitsa, lisyarus@gmail.com, 2021

\documentclass{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{adjustbox}

\usepackage{color}
\usepackage{soul}

\usepackage{hyperref}

\usepackage{tikz}
\usetikzlibrary{decorations}
\usetikzlibrary{decorations.pathreplacing}
\usepackage{xifthen}

\definecolor{red}{rgb}{1,0,0}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{blue}{rgb}{0,0,1}
\definecolor{magenta}{rgb}{0.75,0,0.75}

\makeatletter
\newcommand{\slideimage}[1]{
  \begin{figure}
    \begin{adjustbox}{width=\textwidth, totalheight=\textheight-2\baselineskip-2\baselineskip,keepaspectratio}
      \includegraphics{#1}
    \end{adjustbox}
  \end{figure}
}
\makeatother

\title{Компьютерная графика}
\subtitle{Лекция 5: Текстуры}
\date{2021}

\setbeamertemplate{footline}[frame number]

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
\frametitle{Что такое текстуры?}
\begin{itemize}
\item Изображения в памяти GPU
\pause
\item Их можно читать из шейдеров
\pause
\item В них можно загружать пиксели
\pause
\item В них можно рисовать (вместо рисования в окно)
\pause
\item Поддерживают много специфичных для изображений операций
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Что нужно знать про текстуры?}
\begin{itemize}
\item Типы текстур в OpenGL
\pause
\item Как работать с текстурами в шейдере
\pause
\item Какие есть настройки чтения из текстур
\pause
\item Как загрузить данные в текстуру
\pause
\item Как привязать текстуру к шейдеру
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Что такое текстуры в OpenGL?}
\begin{itemize}
\item Объекты OpenGL
\pause
\item \verb|glGenTextures|, \verb|glDeleteTextures|, \verb|glBindTexture|
\pause
\item \verb|target| - тип текстуры (об этом чуть позже)
\pause
\item Если текстура сделана текущей для какого-то \verb|target|, её никогда нельзя сделать текущей для другого \verb|target|
\begin{itemize}
\item Таким образом, тип текстуры определяется первым вызовом \verb|glBindTexture| для неё
\end{itemize}
\pause
\item ID текущей для \verb|target| текстуры хранится не в контектсе OpenGL, а в т.н. texture unit'ах (о них позже)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Типы текстур}
\begin{itemize}
\item \verb|GL_TEXTURE_1D| - одномерная текстура (полоска пикселей)
\pause
\item \verb|GL_TEXTURE_2D| - двумерная текстура
\pause
\item \verb|GL_TEXTURE_3D| - текстура текстура
\pause
\item \verb|GL_TEXTURE_1D_ARRAY| - массив одномерных текстур одинакового размера
\pause
\item \verb|GL_TEXTURE_2D_ARRAY| - массив двумерных текстур одинакового размера
\pause
\item \verb|GL_TEXTURE_CUBE_MAP| - текстуры, хранящиеся как 6 граней куба
\pause
\item \verb|GL_TEXTURE_CUBE_MAP_ARRAY| - массив cubemap'ов (OpenGL 4.0)
\pause
\item \verb|GL_TEXTURE_RECTANGLE| - прямоугольные текстуры \pause (плохое название, другие текстуры тоже могут быть прямоугольными; в современном OpenGL бесполезны)
\pause
\item \verb|GL_TEXTURE_BUFFER| - текстуры, берущие данные из buffer object'а
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Текстуры в шейдере - samplers}
\begin{itemize}
\item В шейдере текстура представлена uniform-переменной с особым типом, соответствующим типу текстуры и формату пикселей (floating-point / integer / unsigned integer)
\pause
\item \verb|sampler1D/isampler1D/usampler1D|
\pause
\item \verb|sampler2D/isampler2D/usampler2D|
\pause
\item \verb|sampler3D/isampler3D/usampler3D|
\pause
\item \verb|sampler1DArray/isampler1DArray/usampler1DArray|
\pause
\item \verb|sampler2DArray/isampler2DArray/usampler2DArray|
\pause
\item \verb|samplerCube/isamplerCube/usamplerCube|
\pause
\item \verb|samplerBuffer/isamplerBuffer/usamplerBuffer|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Чтение из текстур}
\begin{itemize}
\item Как читать из текстуры в шейдере?
\pause
\item \verb|texture(sampler, coords)| - возвращает \verb|vec4/ivec4/uvec4|
\pause
\item Тип и смысл \verb|coords| зависят от типа текстуры
\pause
\begin{itemize}
\item Для 1D/2D/3D текстур \verb|float/vec2/vec3|: нормированные координаты ([0..1] по каждой оси)
\pause
\item Для 1D/2D array текстур \verb|vec2/vec3|: первые одна/две координаты - нормированные, последняя - номер "слоя"
\pause
\item Для cubemap текстур \verb|vec3|: вектор направления из центра куба, возвращается значение из пересечения луча с поверхностью куба
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Чтение из текстур}
\begin{itemize}
\item Текстура хранит набор дискретных пикселей, но обращение к ней происходит по floating-point координатам
\pause
\item \begin{math}\Rightarrow\end{math} режимы фильтрации текстур
\begin{itemize}
\item \verb|GL_NEAREST| - использовать ближайший к указанным координатам пиксель
\item \verb|GL_LINEAR| - использовать линейную/билинейную/трилинейную интерполяцию между соседними 2/4/8 пикселями (для 1D/2D/3D соответственно)
\item Для array-текстур номер слоя всегда ближайший!
\end{itemize}
\pause
\item Настраиваются отдельно для случая, когда
\begin{itemize}
\item Пиксель текстуры больше пикселя на экране (magnification) - \verb|GL_TEXTURE_MAG_FILTER|
\item Пиксель текстуры меньше пикселя на экране (minification) - \verb|GL_TEXTURE_MIN_FILTER|
\end{itemize}
\end{itemize}
\pause
\begin{verbatim}
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
    GL_NEAREST)
\end{verbatim}
\end{frame}

\begin{frame}
\frametitle{Nearest vs Linear}
\slideimage{nearest_linear.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Mipmaps}
\begin{itemize}
\item Когда пиксель текстуры меньше пикселя на экране (minification), текстура выглядит плохо:
\begin{itemize}
\item \verb|GL_NEAREST| - часть пикселей текстуры не попадают на экран
\item \verb|GL_LINEAR| - нормально до x2 уменьшения, потом пиксели тоже не попадают на экран
\end{itemize}
\pause
\item Решение: mipmap-уровни
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Mipmaps}
\begin{itemize}
\item Mipmaps - уменьшенные копии текстуры для использования при минификации
\pause
\item Для текстуры \begin{math}W\times H\end{math} первый уровень имеет размер \begin{math}\lceil\frac{W}{2}\rceil\times \lceil\frac{H}{2}\rceil\end{math}, второй уровень имеет размер \begin{math}\lceil\frac{W}{4}\rceil\times \lceil\frac{H}{4}\rceil\end{math}, и т.д.
\item Для array-текстур отдельный набор mipmap'ов для каждого слоя
\pause
\item Их можно
\begin{itemize}
\item Загрузить отдельно, так же, как саму текстуру
\item Попросить OpenGL сгенерировать на основе самой текстуры
\item Не использовать
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Mipmaps}
\begin{itemize}
\item Опции для \verb|GL_TEXTURE_MIN_FILTER|:
\pause
\begin{itemize}
\item \verb|GL_NEAREST_MIPMAP_NEAREST| - выбирается ближайший mipmap уровень, с него выбирается ближайший пиксель
\pause
\item \verb|GL_LINEAR_MIPMAP_NEAREST| - выбирается ближайший mipmap уровень, с него делается интерполяция ближайших пикселей
\pause
\item \verb|GL_NEAREST_MIPMAP_LINEAR| - выбираются два ближайших mipmap уровня, с них выбираются ближайшие пиксели, между ними происходит линейная интерполяция (включено по умолчанию)
\pause
\item \verb|GL_LINEAR_MIPMAP_LINEAR| - выбираются два ближайших mipmap уровня, в них делается интерполяция ближайших пикселей, между ними происходит линейная интерполяция
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Mipmaps}
\begin{itemize}
\item По умолчанию включен \verb|GL_NEAREST_MIPMAP_LINEAR|
\item Если вы забыли сгенерировать/загрузить mipmap-уровни, текстура считается невалидной, и может рисоваться всегда чёрной
\item Не забывайте выставлять правильные min/mag filter и/или генерировать mipmap'ы!
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Анизотропная фильтрация}
\begin{itemize}
\item Текстура может быть нормального размера по одной оси, и маленькая по другой
\pause
\item Большой mipmap уровень хорош для одной оси, маленький - для другой
\pause
\item Решение: анизотропная фильтрация
\pause
\item Есть в OpenGL 4.6, но почти везде доступна через расширение \verb|EXT_texture_filter_anisotropic|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Wrapping mode}
\begin{itemize}
\item При чтении из текстуры координаты могут выходить за пределы диапазона
\pause
\item При \verb|GL_LINEAR| для точек у границы текстуры может не найтись достаточное количество соседних пикселей
\pause
\item \begin{math}\Rightarrow\end{math} Wrapping mode:
\begin{itemize}
\item \verb|GL_CLAMP_TO_EDGE| - брать пиксель с границы
\item \verb|GL_REPEAT| (по умолчанию) - повторять текстуру
\item \verb|GL_MIRRORED_REPEAT| - повторять текстуру, отражая её на каждый повтор
\end{itemize}
\pause
\item Настраивается отдельно для каждой координаты: S, T, R
\end{itemize}
\begin{verbatim}
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
    GL_CLAMP_TO_EDGE)
\end{verbatim}
\end{frame}

\begin{frame}
\frametitle{Wrapping}
\slideimage{wrapping.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Выбор mipmap уровня}
\begin{itemize}
\item Как GPU понимает, какой выбрать mipmap-уровень, и происходит ли minification/magnification?
\pause
\item По значениям в соседних пикселях
\pause
\item Фрагментный шейдер всегда запускается на группах 2x2 пикселя (даже если часть из них не были растеризованы)
\pause
\item В GLSL есть функции \verb|dFdx/dFdy| - вычисляют разницу некой величины для пары соседних пикселей в группе 2x2
\pause
\item По \verb|dFdx(coords)| и \verb|dFdy(coords)| вычисляется mipmap-уровень
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Чтение из текстур}
\begin{itemize}
\item \verb|textureLod| - обратиться напрямую к указанному mipmap-уровню (LOD = level of detail)
\pause
\item \verb|texelFetch| - обратиться напрямую к указанному пикселю, минуя всю фильтрацию
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Формат текстуры}
\begin{itemize}
\item Текстура - набор (1D/2D/3D массив или 6 2D массивов) пикселей
\pause
\item Пиксель - 1, 2, 3 или 4 компоненты в определённом формате
\pause
\item Форматов очень много, вот часто встречающиеся:
\begin{itemize}
\item \verb|GL_RGB8| - 3 нормированных 8-битных канала
\item \verb|GL_RGBA8| - 4 нормированных 8-битных канала
\item \verb|GL_RGBA32F| - 4 32-битных floating-point канала
\item \verb|GL_DEPTH_COMPONENT24| - специальный формат для z-буфера
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Загрузить данные в текстуру}
\begin{itemize}
\item 1D: \verb|glTexImage1D|
\pause
\item 2D, 1D array или грань cubemap: \verb|glTexImage2D|
\pause
\item 3D или 2D array: \verb|glTexImage3D|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Загрузить данные в текстуру}
\begin{verbatim}
glTexImage2D(GLenum target, GLint level,
  GLint internalFormat,
  GLsizei width, GLsizei height, GLint border,
  GLenum format, GLenum type, const GLvoid * data);
\end{verbatim}
\begin{itemize}
\item \verb|target| - тип текстуры (например, \verb|GL_TEXTURE_2D|)
\item \verb|level| - mipmap level, который мы хотим загрузить (0 для основной текстуры)
\item \verb|internalFormat| - формат хранения пикселей (например, \verb|GL_RGBA8|)
\item \verb|width|, \verb|height| - размер в пикселях
\item \verb|border| - легаси, должно быть 0
\item \verb|format| - какие компоненты есть в массиве \verb|data| (например, \verb|GL_RGB|)
\item \verb|type| - какого типа компоненты в массиве \verb|data| (например, \verb|GL_UNSIGNED_BYTE|)
\item \verb|data| - указатель на массив пикселей (сначала первая строка пикселей, потом вторая, и т.д.)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Загрузить данные в текстуру}
\begin{itemize}
\item Если \verb|data = nullptr|, под текстуру выделится память, но данные не будут записаны
\pause
\item Есть ограничения на возможные пары \verb|format| и \verb|type| (например, \verb|type = GL_UNSIGNED_SHORT_5_6_5| требует \verb|format = GL_RGB|)
\pause
\item \verb|format + type| может не совпадать с \verb|internalFormat|, тогда происходит преобразование в \verb|internalFormat|
\pause
\item По умолчанию ожидается, что начало каждой строки пикселей в массиве \verb|data| выровнено на 4 байта
\item Это может нарушиться, например, с \verb|format = GL_RGB| и \verb|type = GL_UNSIGNED_BYTE| с нечётной шириной текстуры
\item Настраивается с помощью \verb|glPixelStorei(GL_UNPACK_ALIGNMENT, 1)|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Генерация mipmap}
\begin{itemize}
\item После загрузки нулевого mipmap-уровня, можно сгенерировать все остальные с помощью \verb|glGenerateMipmap(target)|
\end{itemize}
\end{frame}

\end{document}