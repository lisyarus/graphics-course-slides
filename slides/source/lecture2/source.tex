% (c) Nikita Lisitsa, lisyarus@gmail.com, 2021

\documentclass{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{adjustbox}

\usepackage{color}
\usepackage{soul}

\usepackage{hyperref}

\definecolor{blue}{rgb}{0,0,1}
\definecolor{red}{rgb}{1,0,0}

\makeatletter
\newcommand{\slideimage}[1]{
  \begin{figure}
    \begin{adjustbox}{width=\textwidth, totalheight=\textheight-2\baselineskip-2\baselineskip,keepaspectratio}
      \includegraphics{#1}
    \end{adjustbox}
  \end{figure}
}
\makeatother

\title{Компьютерная графика}
\subtitle{Лекция 2: Графический конвейер, шейдеры, аффинные преобразования}
\date{2021}

\begin{document}

\frame{\titlepage}

\begin{frame}
\frametitle{Растеризация}
\begin{itemize}
\item Растеризация -- превращение геометрического примитива (точки, линии, треугольника, прямоугольника, круга, и т.д.) в набор соответствующих ему пикселей на экране/изображении
\item Превращение векторных данных в растровые
\pause
\item За нас её делает OpenGL!
\pause
\item Некоторые современные графические движки GPU (Unreal 5 Nanite) делают растеризацию сами с помощью compute шейдеров
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Растеризация: точка}
\begin{itemize}
\item Как растеризовать точку \begin{math}(x, y)\end{math}?
\pause
\begin{verbatim}
set_pixel(round(x), round(y), color);
\end{verbatim}
\pause
\item В OpenGL: \verb|GL_POINTS|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Растеризация: линия}
\begin{itemize}
\item Как растеризовать линию \begin{math}(x_1, y_1) \dots (x_2, y_2)\end{math}?
\pause
\item Алгоритм Брезенхэма
\pause
\item Есть вариация алгоритма для рисования окружностей
\pause
\item В OpenGL: \verb|GL_LINES|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Растеризация: прямоугольник}
\begin{itemize}
\item Как растеризовать прямоугольник \begin{math}[x_1\dots x_2]\times[y_1\dots y_2]\end{math}?
\end{itemize}
\pause
\begin{verbatim}
for (int x = round(x_1); x <= round(x_2); ++x) {
    for (int y = round(y_1); y <= round(y_2); ++y) {
        set_pixel(x, y, color);
    }
}
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Растеризация: треугольник}
\begin{itemize}
\item Как растеризовать треугольник с вершинами \begin{math}(x_1, y_1), (x_2, y_2), (x_3, y_3)\end{math}?
\pause
\item Растеризуем ограничивающий прямоугольник, проверяя пиксели на вхождение в треугольник
\pause
\begin{verbatim}
int xmin = min(round(x_1), round(x_2), round(x_3));
int xmax = max(round(x_1), round(x_2), round(x_3));

int ymin = min(round(y_1), round(y_2), round(y_3));
int ymax = max(round(y_1), round(y_2), round(y_3));

for (int x = xmin; x <= xmax; ++x) {
    for (int y = ymin; y <= ymax; ++y) {
        if (inside_triangle(x, y, ...))
            set_pixel(x, y, color);
    }
}
\end{verbatim}
\pause
\item В OpenGL: \verb|GL_TRIANGLES|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Растеризация: круг}
\begin{itemize}
\item Как растеризовать круг с центром \begin{math}(x_0, y_0)\end{math} и радиусом \begin{math}R\end{math}?
\pause
\item Растеризуем ограничивающий прямоугольник, проверяя пиксели на вхождение в круг
\end{itemize}
\pause
\begin{verbatim}
int xmin = round(x_0 - R);
int xmax = round(x_0 + R);

int ymin = round(y_0 - R);
int ymax = round(y_0 + R);

for (int x = xmin; x <= xmax; ++x) {
    for (int y = ymin; y <= ymax; ++y) {
        if (sqr(x - x_0) + sqr(y - y_0) <= sqr(R))
            set_pixel(x, y, color);
    }
}
\end{verbatim}
\end{frame}

\begin{frame}<1>[fragile,label=rasterization]
\frametitle{Растеризация: OpenGL}
\begin{itemize}
\item Пиксель растеризуется, если центр пикселя содержится в треугольнике
\pause
\item Если у двух треугольников есть общее ребро (и они не пересекаются внутренностями), то
\begin{itemize}
\item Каждый пиксель будет принадлежать ровно одному треугольнику, т.е. не будет наложения
\item Ни один пиксель не будет пропущен, т.е. не будет "дырок"
\end{itemize}
\pause
\item Подробнее: \href{https://en.wikibooks.org/wiki/GLSL_Programming/Rasterization}{en.wikibooks.org/wiki/GLSL\_Programming/Rasterization}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Растеризация: OpenGL}
\slideimage{pixel-covered.png}
\end{frame}

\againframe<2>{rasterization}

\begin{frame}
\frametitle{Растеризация: OpenGL}
\slideimage{triangle-rasterization.png}
\end{frame}

\begin{frame}
\frametitle{Растеризация: OpenGL}
Не будет "дырок":
\slideimage{triangle-rasterization-hole.png}
\end{frame}

\begin{frame}
\frametitle{Растеризация: OpenGL}
Не будет наложения пикселей:
\slideimage{triangle-rasterization-overlap.png}
\end{frame}

\againframe<3>{rasterization}

\begin{frame}[fragile]
\frametitle{Растеризация: OpenGL}
\begin{itemize}
\item В современном OpenGL есть только три примитива для растеризации:
\pause
\item Точки: \verb|GL_POINTS|
\pause
\item Линии: \verb|GL_LINE_STRIP|, \verb|GL_LINE_LOOP|, \verb|GL_LINES|
\pause
\item Треугольники: \verb|GL_TRIANGLE_STRIP|, \verb|GL_TRIANGLE_FAN|, \verb|GL_TRIANGLES|
\pause
\item Для геометрических шейдеров: \verb|GL_LINE_STRIP_ADJACENCY|, \verb|GL_LINES_ADJACENCY|, \verb|GL_TRIANGLE_STRIP_ADJACENCY|, \verb|GL_TRIANGLES_ADJACENCY|
\end{itemize}
\end{frame}

\begin{frame}<1>[fragile,label=back_face_culling]
\frametitle{Back-face culling}
\begin{itemize}
\item По умолчанию в OpenGL треугольники, вершины которых оказываются на экране в порядке обхода \textbf{по часовой стрелке}, {\color{red}не рисуются}
\pause
\begin{itemize}
\item Чтобы не рисовать треугольники, которые всё равно будут скрыты другими треугольниками спереди
\end{itemize}
\pause
\item Включить/выключить это поведение: \verb|glEnable(GL_CULL_FACE)| или \verb|glDisable(GL_CULL_FACE)|
\pause
\item Настроить, какие треугольники будут скрываться: \verb|glCullFace(GL_BACK)|, \verb|glCullFace(GL_FRONT)|, \verb|glCullFace(GL_FRONT_AND_BACK)|
\pause
\item Настроить, какие треугольники считаются \verb|FRONT|, а какие - \verb|BACK|: \verb|glFrontFace(GL_CCW)|, \verb|glFrontFace(GL_CW)|
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Back-face culling}
\slideimage{back-face-culling.png}
\end{frame}

\againframe<2->{back_face_culling}

\begin{frame}
\frametitle{Группировка вершин по примитивам (primitive assembly)}
\slideimage{primitives.png}
\end{frame}

\begin{frame}[fragile]
\frametitle{Графический конвейер (graphics pipeline)}
\begin{itemize}
\pause
\item Входной поток вершин (vertex stream)
\pause
\item Вершинный шейдер: обрабатывает вершины по одной
\begin{itemize}
\item Должен записать \verb|vec4 gl_Position|
\end{itemize}
\pause
\item Сборка примитивов (primitive assembly)
\pause
\item Преобразование в оконную систему координат (viewport transform)
\begin{itemize}
\item \begin{math}X: [-1, 1] \rightarrow [0, width]\end{math}
\item \begin{math}Y: [-1, 1] \rightarrow [height, 0]\end{math} (-1 внизу, 1 вверху)
\item \verb|glViewport(0, 0, width, height)|
\end{itemize}
\pause
\item Back-face culling
\pause
\item Растеризация примитивов: примитив превращается в набор пикселей
\begin{itemize}
\item Линейная интерполяция значений, переданных из вершинного шейдера во фрагментный
\end{itemize}
\pause
\item Пиксельный (фрагментный) шейдер: обрабатывает пиксели по одному
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Графический конвейер (graphics pipeline)}
\begin{itemize}
\item Мы пропустили много важных частей конвейера
\item Будем их по чуть-чуть добавлять в течение курса
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Вершинный (vertex) шейдер}
\begin{itemize}
\pause
\item Входные данные:
\pause
\begin{itemize}
\item Аттрибуты вершин (мы позже узнаем, как их задавать) - свои для каждой вершины
\pause
\item Uniform-переменные - глобальные значения, не меняющиеся в течение одного вызова команды рисования (\verb|glDrawArrays|):

\verb|uniform float scale|
\end{itemize}
\pause
\item Выходные данные:
\begin{itemize}
\item \verb|vec4 gl_Position|
\pause
\item Переменные, интерполированное значение которых попадёт во фрагментный (пиксельный) шейдер: \verb|out vec3 color|
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Флагментный (пиксельный, fragment) шейдер}
\begin{itemize}
\pause
\item Входные данные:
\pause
\begin{itemize}
\item Uniform-переменные
\pause
\item Проинтерполированные \verb|out|-переменные вершинного шейдера: \verb|in vec3 color|
\pause
\item \verb|gl_FragCoord| - координаты пикселя (\begin{math}-1 \dots 1\end{math})
\pause
\item И много других: \href{https://www.khronos.org/opengl/wiki/Fragment_Shader/Defined_Inputs}{khronos.org/opengl/wiki/Fragment\_Shader/Defined\_Inputs}
\end{itemize}
\pause
\item Выходные данные:
\begin{itemize}
\item \verb|layout (location = 0) out vec4 out_color;| - выходной цвет в формате RGBA
\pause
\item Может быть несколько, об этом поговорим позже
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Языки описания шейдеров}
\begin{itemize}
\item OpenGL - GLSL (GL Shading Language)
\pause
\item DirectX - HLSL (High-Level Shading Language)
\pause
\item DurectX (до 2012) - Cg (C for Graphics), deprecated
\pause
\item \href{https://en.wikipedia.org/wiki/Shading_language}{en.wikipedia.org/wiki/Shading\_language}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Язык описания шейдеров GLSL}
\begin{itemize}
\item Похож на C
\pause
\item Типы данных:
\pause
\begin{itemize}
\item Скалярные: \verb|bool|, \verb|int|, \verb|uint|, \verb|float|
\pause
\item Векторные: \verb|bvec2|, \verb|bvec3|, \verb|bvec4|, \verb|ivec2|, ..., \verb|uvec2|, ..., \verb|vec2|, ...
\pause
\item Матричные: \verb|mat2|, \verb|mat3|, \verb|mat4|, \verb|mat2x4|, ...
\pause
\item В GLSL 400 или с расширением \verb|GL_ARB_gpu_shader_fp64| есть \verb|double|, \verb|dvec2|, ..., \verb|dmat2|, ...
\end{itemize}
\pause
\item Программа должна начинаться с \verb|#version <версия> [ <профиль> ]|
\pause
\item Программа должна содержать функцию \verb|void main()|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Язык описания шейдеров GLSL}
\begin{itemize}
\item Есть стандартные операции: \verb|+|, \verb|-|, \verb|*|, \verb|/|, \verb|<|, \verb|==|, ...
\pause
\item Доступ к координатам векторов: \verb|a.x = b.y|
\pause
\item Доступ к элементам матриц: \verb|m[column][row]|
\pause
\item Есть полезные математические функции: \verb|pow|, \verb|sin|, \verb|cos|, \verb|dot|, \verb|cross|, \verb|length|, \verb|normalize|, ...
\pause
\item Можно умножать матрицу на вектор: \verb|matrix * vector|
\pause
\item Можно умножать матрицу на матрицу: \verb|matrix1 * matrix2|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Язык описания шейдеров GLSL}
\begin{itemize}
\item Есть массивы: \verb|float array[5];|
\pause
\begin{itemize}
\item Инициализация: \verb|float array[5] = float[5](0.0, 1.0, 2.0, 3.0, 4.0);|
\end{itemize}
\pause
\item Константы (известные на момент компиляции): \verb|const float PI = 3.141592;|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Язык описания шейдеров GLSL}
\begin{itemize}
\item Ветвление: \verb|if (condition) { ... } else { ... }|
\pause
\item Циклы: \verb|for (int i = 0; i < 10; ++i) { ... }|
\begin{itemize}
\item Число итераций цикла должно быть константой, известной на момент компиляции шейдера
\item Не может зависеть от uniform-переменных, аттрибутов вершин, и т.д.
\end{itemize}
\pause
\item Функции: \begin{verbatim}vec3 reflect(vec3 v, vec3 n) {
    return v - 2.0 * n * dot(v, n);
}\end{verbatim}
\pause
\begin{itemize}
\item Могут вызывать другие функции
\pause
\item Рекурсия запрещена
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Полезные ресурсы о шейдерах}
\begin{itemize}
\item Туториал: \href{https://learnopengl.com/Getting-started/Shaders}{learnopengl.com/Getting-started/Shaders}
\item Туториал: \href{https://www.lighthouse3d.com/tutorials/glsl-tutorial}{lighthouse3d.com/tutorials/glsl-tutorial}
\pause
\item Книжка-учебник с большим количеством примеров сложных шейдеров: \href{https://thebookofshaders.com/00/}{The Book of Shaders}
\pause
\item Онлайн-редактор шейдеров: \href{https://shadertoy.com/}{shadertoy.com}
\end{itemize}
\end{frame}

\end{document}